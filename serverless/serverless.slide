Gettin' Jiggy Wit Serverless 

A closer look at the world of Serverless architecture

Douglas Chimento
Outbrain Inc.
dchimento@outbrain.com
https://presentations.dougchimento.com/

* What we want
- Focus on core biz logic
- Automatic scaling 
- We don't care about the OS
- Simple way to deploy our code

*The* *80/20* *Rule*
- Most of the time our code executes quickly (< 100ms)
- Responds to HTTP events (requests)
- Latency is not significant concern
- Simple CRUD operations
: Has anyone experience HTTP 500 errors because your service was overloaded? 

* What does Serverless mean?
- No servers to provision or manage
- Scale with usage
- Built in fault-tolerance
- Never pay for idle/unused capacity
- Event driven
: Serverless should be called event driven architecture 

* Lexicon
- PaaS - Platform as a Service
- BaaS - Backend as a Service
- FaaS - Function as a Service

The combination of these concepts are *serverless*

* _
.background evolution.jpg
: Ops and Finance mostly benefit from VM

* Components of serverless
.background lambda_in_action.png
.html lambda_in_action.html

* Key Requirement
.html twitter.html

* Offerings
- AWS lambda (2015)
- Google Cloud Functions
- Azure Functions
- IBM OpenWhisk
- Kubeless

* Mental shift
- Microservices to the extreme
- Stateless (ephemeral) to the extreme
- Async is (mostly) irrelevant
- Focus on one task and do it well
- Specific resource (memory) allocation
- Event driven programming

: Talk more about async later
: You shift to event resource allocation

* Extreme Microservices
- Traditional style -  Multiple endpoints in one service
  public class UserService {

   ComposableFuture<Response> createUser(Request request) {
         //Do stuff
    }

   ComposableFuture<Response> getUser(Request request) {
          //Do stuff
    }
  }

- In Serverless you break up *endpoints* (functions) into isolated deployments
- Distinct deployments for _creating_ and _getting_ users 

: Take your time with this slide

* Fault Tolerance
- Each "event" is protected; Running in its own linux namespaces (e.g. docker)
- Fatal failures do not bring down a service or a server (out of disk space)
- No restarting
- No OutOfMemory or GC pauses that affects other requests

In Serverless, there are no *thread* *pools*, you are bound by the number of available servers.

Number of Servers (Instances) == Number of Threads

: As a consequence of isoloated/distinct deployments you get Automatic fault tolerance

* Examples 


* Example - AdServer
Letâ€™s think about an online ad system - when a user clicks on an advertisement you want to very quickly redirect them to the target of the ad, but at the same time you need to collect the fact that the click has happened so that you can charge the advertiser. 

.image ad_server_click.svg

* Example - Image thumbnail
.background image_thumbnail.png
.html image_thumbnail.html


* What's really going on?
- Your code and dependencies are on local storage
- A generic docker container *mounts* that code and runs something like this:
  #!/bin/bash
  # set environment variables (especially Main-Class)
  # set up logger, metrics
  ... 
  docker run -p :$_SERVER_PORT \ 
    --env-file faas.env \
    --volume /local/path/to/code:/var/task --memory 512 \
    amazonlinux:2017.03 bootstrap-main-wrapper.sh
  ...
- Capture exit code
- Send logs & Bill!
: Recall tweet - Docker is a good fit to bring up servers quickly
: End with "lets's look at some code"

* I code therefore I think
.code -numbers example1.go
: Is testing easy ? 
: Integration is almost non-existent

- compile, zip, upload
- register an "event" to trigger this code

What's going on with `lambda.Start()` ?

* Hot/Warm/Cold Invocation
.code -numbers start.go
- RPC server
- Maps `_SERVER_PORT` on *host* server into the container
: Hot Docker image is accepting connections
: Warm Docker is paused 
: Cold Docker is being brough up
: Recall that the docker image is running with an exposed port

* Putting it all together 
: Nginix public HTTPS server 
: Controller - gatekeeper of the system orchestrator
: CouchDB  - credentials, metadata, namespaces, and the definitions of actions, triggers, and rules
: Consul - State management, service discovery
: Invoker - spins up docker & unit of execution for the chosen Action
.image whisk.png 600 1000

* Review
- Just write your function! 
- Package your code and upload
- Register your "event" to your *function*
.image southpark.png 400 800

* A personal experience with Serverless
I have a bare metal server in a DC. Hackers were constantly trying to SSH into my server. I was seeing a lot of these messages:

  Failed password for invalid user hacker from 212.143.121...

Why? What password are these hackers trying to use?
Is there a way to capture the password?
Let's grep OpenSSH source code

  egrep -l 'passwd|password' *.c
  ...
  auth-pam.c
  auth-passwd.c
  auth-rhosts.c
  auth-shadow.c
  ...

hmmm, let's look at auth-passwd.c 

* Passwd pot - A honeypot for login attempts
  
So I hacked [[https://github.com/openssh/openssh-portable/compare/master...dougEfresh:sshd-passwd-pot#diff-7a1dfcdf16db2cb5024ea0c3b057c4d8R203][auth-passwd.c]] to log passwords
  
  Mar  6 14:13:00 2e6474da0e40 sshd[28474]: 
  { "time": 1520345580398, 
  "user": "root", "passwd": "hacker", 
  "remoteAddr": "42.7.26.61", "remotePort": 37084, 
  "remoteName": "42.7.26.61", "remoteVersion": "OpenSSH_6.2...", 
  "application": "OpenSSH_7.4p1", "protocol": "ssh"
  }
   
But I want to do some data analytics on these passwords. 

- Which country is attacking me?
- What is the most common username/password?
- What software are they using to hack?

I want to send this data to a central data store

* *
.background passwdpot.png 

* Gotchas
- Logging and debugging can be very difficult 
- Your code is ephemeral on a massive server farm
- Tracing requests from frontend to multiple serverless calls is a nightmare
- Functions end up simple, infrastructure becomes more complex
What if *one* of those hundreds of servers is configured incorrectly (wrong firewall rules) ?

* Questions ?

* Resources
- [[https://aws.amazon.com/documentation/lambda/][AWS]]
- [[http://openwhisk.incubator.apache.org/][OpenWhisk]]
- [[https://www.openstack.org/software/][OpenStack]]
- [[https://serverless.com/][Serverless]]
- [[https://github.com/alestic/lambdash][lambdash]]
- [[https://github.com/dougEfresh/passwd-pot/blob/master/lambda/handler.go][PasswdPot]]
- [[https://github.com/dougEfresh/sshd-passwd-pot][OpenSSH Passwd Hack]]
